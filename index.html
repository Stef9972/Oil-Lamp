<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Advanced 3D Model Viewer</title>
    <!-- Three.js and required libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/DeviceOrientationControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/WebXR.js"></script>
    <!-- Loading spinner CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            touch-action: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        /* Controls Panel */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 100;
            backdrop-filter: blur(10px);
            max-width: 300px;
            width: 90%;
        }
        
        @media (max-width: 768px) {
            #controls {
                padding: 15px;
                max-width: calc(100vw - 40px);
            }
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-title i {
            color: #667eea;
        }
        
        /* Buttons */
        .btn {
            padding: 12px 20px;
            margin: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }
        
        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(240, 147, 251, 0.6);
        }
        
        .btn-sm {
            padding: 8px 15px;
            font-size: 13px;
        }
        
        /* Mobile-specific buttons */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            gap: 10px;
        }
        
        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #667eea;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .mobile-btn:active {
            transform: scale(0.9);
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                flex-direction: column;
            }
        }
        
        /* Dimensions Panel */
        #dimensions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 100;
            backdrop-filter: blur(10px);
            min-width: 180px;
            display: none;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .dimension-title {
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            text-align: center;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        .dimension-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .dimension-label {
            font-weight: 600;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dimension-value {
            font-weight: 700;
            color: #667eea;
            font-size: 18px;
        }
        
        .dimension-unit {
            font-size: 12px;
            color: #888;
            margin-left: 2px;
        }
        
        /* Loading Spinner */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 70px;
            height: 70px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            font-size: 20px;
            font-weight: 600;
            text-align: center;
            margin-top: 20px;
        }
        
        .loading-details {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
        }
        
        /* Progress Bar */
        .progress-container {
            width: 80%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 8px;
            background: white;
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 16px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            max-width: 90%;
        }
        
        .instructions-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .instructions-content {
            color: #666;
            line-height: 1.6;
        }
        
        /* AR Mode Styles */
        .ar-button {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .ar-button:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        
        /* Timer Display */
        .timer-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
            z-index: 100;
        }
        
        /* Wireframe Overlay Style */
        .wireframe-active {
            filter: brightness(1.2);
        }
        
        /* Responsive Adjustments */
        @media (max-width: 480px) {
            #controls {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
            }
            
            #dimensions {
                top: 10px;
                right: 10px;
                max-width: calc(100% - 20px);
            }
            
            #instructions {
                bottom: 80px;
                font-size: 12px;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 13px;
            }
            
            .dimension-value {
                font-size: 16px;
            }
        }
        
        /* Landscape Mode Adjustments */
        @media (max-height: 600px) and (orientation: landscape) {
            #controls {
                padding: 10px;
                max-width: 250px;
            }
            
            #dimensions {
                max-width: 150px;
            }
            
            #instructions {
                display: none;
            }
        }
        
        /* Touch Device Specific */
        @media (hover: none) and (pointer: coarse) {
            .btn:hover {
                transform: none;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Loading 3D Model...</div>
        <div class="loading-details" id="loadingDetails">Initializing viewer</div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>

    <!-- Main Container -->
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <!-- Controls Panel -->
        <div id="controls">
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-exchange-alt"></i>
                    Model View
                </div>
                <button id="switchModel" class="btn">
                    <i class="fas fa-layer-group"></i>
                    Switch to Cross-Section
                </button>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-expand-arrows-alt"></i>
                    View Controls
                </div>
                <button id="resetView" class="btn btn-secondary">
                    <i class="fas fa-redo"></i>
                    Reset View
                </button>
                <button id="autoRotate" class="btn btn-secondary">
                    <i class="fas fa-sync"></i>
                    Auto Rotate
                </button>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-cube"></i>
                    Display Options
                </button>
                <div style="display: flex; gap: 10px;">
                    <button id="toggleWireframe" class="btn btn-sm">
                        <i class="fas fa-th"></i>
                        Wireframe
                    </button>
                    <button id="toggleGrid" class="btn btn-sm">
                        <i class="fas fa-th-large"></i>
                        Grid
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-ruler-combined"></i>
                    Measurement
                </div>
                <button id="measureDistance" class="btn">
                    <i class="fas fa-ruler"></i>
                    Measure Distance
                </button>
            </div>
        </div>
        
        <!-- Dimensions Panel -->
        <div id="dimensions">
            <div class="dimension-title">
                <i class="fas fa-ruler"></i>
                DIMENSIONS
            </div>
            <div class="dimension-item">
                <div class="dimension-label">
                    <i class="fas fa-arrows-alt-h"></i>
                    X (Width)
                </div>
                <span class="dimension-value">0.00<span class="dimension-unit">mm</span></span>
            </div>
            <div class="dimension-item">
                <div class="dimension-label">
                    <i class="fas fa-arrows-alt-v"></i>
                    Y (Height)
                </div>
                <span class="dimension-value">0.00<span class="dimension-unit">mm</span></span>
            </div>
            <div class="dimension-item">
                <div class="dimension-label">
                    <i class="fas fa-arrows-alt-h fa-rotate-90"></i>
                    Z (Depth)
                </div>
                <span class="dimension-value">0.00<span class="dimension-unit">mm</span></span>
            </div>
            <div class="dimension-item" id="thicknessItem" style="display: none;">
                <div class="dimension-label">
                    <i class="fas fa-layer-group"></i>
                    Thickness
                </div>
                <span class="dimension-value" id="thicknessValue">0.00<span class="dimension-unit">mm</span></span>
            </div>
            <div class="dimension-item">
                <div class="dimension-label">
                    <i class="fas fa-weight-hanging"></i>
                    Volume
                </div>
                <span class="dimension-value" id="volumeValue">0.00<span class="dimension-unit">cm³</span></span>
            </div>
        </div>
        
        <!-- Timer Display -->
        <div class="timer-display" id="timerDisplay">
            Dimensions will hide in: <span id="countdown">05:00</span>
        </div>
        
        <!-- AR Button -->
        <button id="arButton" class="btn ar-button" style="display: none;">
            <i class="fas fa-vr-cardboard"></i>
            View in AR
        </button>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <button class="mobile-btn" id="mobileRotate">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button class="mobile-btn" id="mobileZoomIn">
                <i class="fas fa-search-plus"></i>
            </button>
            <button class="mobile-btn" id="mobileZoomOut">
                <i class="fas fa-search-minus"></i>
            </button>
            <button class="mobile-btn" id="mobileReset">
                <i class="fas fa-home"></i>
            </button>
        </div>
        
        <!-- Instructions -->
        <div id="instructions">
            <div class="instructions-title">
                <i class="fas fa-info-circle"></i>
                HOW TO INTERACT
            </div>
            <div class="instructions-content">
                <span style="color: #667eea;">• Tap/Drag:</span> Rotate 
                <span style="color: #667eea; margin-left: 15px;">• Scroll/Pinch:</span> Zoom 
                <span style="color: #667eea; margin-left: 15px;">• Right-click/Hold:</span> Pan
            </div>
        </div>
    </div>

    <script>
        // Main variables
        let scene, camera, renderer, controls;
        let mainModel, crossSectionModel;
        let currentModel = null;
        let dimensionsVisible = false;
        let dimensionTimer = null;
        let countdownTimer = null;
        let firstClickTime = null;
        let clickCount = 0;
        let autoRotate = false;
        let gridVisible = true;
        let wireframeVisible = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        let arSupported = false;
        let isARMode = false;
        let measurementMode = false;
        let measurePoints = [];
        let measureLine = null;
        
        // Initialize the 3D viewer
        async function init() {
            updateLoadingStatus("Initializing 3D engine...");
            
            try {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf8f9fa);
                
                // Setup camera
                camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(5, 5, 5);
                
                // Setup renderer
                renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Setup controls with mobile optimizations
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                controls.panSpeed = isMobile ? 0.5 : 1.0;
                controls.zoomSpeed = isMobile ? 0.5 : 1.0;
                controls.minDistance = 0.1;
                controls.maxDistance = 50;
                controls.maxPolarAngle = Math.PI;
                
                // Add lights
                addLights();
                
                // Add grid helper
                addGridHelper();
                
                // Check AR support
                checkARSupport();
                
                // Load models with progress tracking
                updateLoadingStatus("Loading 3D models...");
                await loadModelsWithProgress();
                
                // Setup event listeners
                setupEventListeners();
                
                // Setup mobile gesture handlers
                if (isMobile) {
                    setupMobileGestures();
                }
                
                // Start animation loop
                animate();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 500);
                
            } catch (error) {
                console.error('Initialization error:', error);
                updateLoadingStatus(`Error: ${error.message}`);
            }
        }
        
        // Update loading status
        function updateLoadingStatus(message, progress = null) {
            document.getElementById('loadingDetails').textContent = message;
            if (progress !== null) {
                document.getElementById('progressBar').style.width = `${progress}%`;
            }
        }
        
        // Check AR support
        async function checkARSupport() {
            if ('xr' in navigator) {
                try {
                    arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (arSupported) {
                        document.getElementById('arButton').style.display = 'block';
                    }
                } catch (error) {
                    console.warn('AR not supported:', error);
                }
            }
        }
        
        // Add lights to scene
        function addLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Directional light (sun-like)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Hemisphere light for natural outdoor lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3);
            scene.add(hemisphereLight);
        }
        
        // Add grid helper
        function addGridHelper() {
            const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
            gridHelper.position.y = -0.01;
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);
        }
        
        // Load models with progress tracking
        async function loadModelsWithProgress() {
            const loader = new THREE.GLTFLoader();
            
            return new Promise((resolve, reject) => {
                let modelsLoaded = 0;
                const totalModels = 2;
                
                // Load main model
                updateLoadingStatus("Loading main model...", 25);
                loader.load('main.glb', 
                    function(gltf) {
                        modelsLoaded++;
                        updateLoadingStatus(`Loading models... (${modelsLoaded}/${totalModels})`, 25 + (modelsLoaded * 25));
                        
                        mainModel = gltf.scene;
                        mainModel.name = 'main';
                        setupModel(mainModel);
                        
                        // Load cross-section model
                        updateLoadingStatus("Loading cross-section...", 50);
                        loader.load('cross-section.glb',
                            function(gltf) {
                                modelsLoaded++;
                                updateLoadingStatus(`Loading models... (${modelsLoaded}/${totalModels})`, 25 + (modelsLoaded * 25));
                                
                                crossSectionModel = gltf.scene;
                                crossSectionModel.name = 'cross-section';
                                setupModel(crossSectionModel);
                                crossSectionModel.visible = false;
                                
                                // Add to scene
                                scene.add(mainModel);
                                scene.add(crossSectionModel);
                                currentModel = mainModel;
                                
                                // Center and scale models
                                centerModel(mainModel);
                                centerModel(crossSectionModel);
                                
                                // Calculate initial dimensions
                                calculateAndDisplayDimensions();
                                
                                updateLoadingStatus("Finalizing...", 100);
                                setTimeout(resolve, 500);
                            },
                            // Progress callback
                            function(xhr) {
                                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                                updateLoadingStatus(`Loading cross-section... ${percent}%`, 50 + (percent / 2));
                            },
                            // Error callback
                            function(error) {
                                console.error('Error loading cross-section:', error);
                                updateLoadingStatus("Creating placeholder model...", 75);
                                createPlaceholderCrossSection();
                                modelsLoaded++;
                                resolve();
                            }
                        );
                    },
                    // Progress callback
                    function(xhr) {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                        updateLoadingStatus(`Loading main model... ${percent}%`, percent / 4);
                    },
                    // Error callback
                    function(error) {
                        console.error('Error loading main model:', error);
                        updateLoadingStatus("Creating placeholder model...", 25);
                        createPlaceholderMainModel();
                        modelsLoaded++;
                        resolve();
                    }
                );
            });
        }
        
        // Create placeholder main model
        function createPlaceholderMainModel() {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x3498db,
                metalness: 0.1,
                roughness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            });
            mainModel = new THREE.Mesh(geometry, material);
            mainModel.name = 'main';
            mainModel.castShadow = true;
            mainModel.receiveShadow = true;
            scene.add(mainModel);
            currentModel = mainModel;
        }
        
        // Create placeholder cross-section
        function createPlaceholderCrossSection() {
            const geometry = new THREE.BoxGeometry(1.8, 1.8, 0.5);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xe74c3c,
                metalness: 0.1,
                roughness: 0.5,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            crossSectionModel = new THREE.Mesh(geometry, material);
            crossSectionModel.name = 'cross-section';
            crossSectionModel.visible = false;
            crossSectionModel.castShadow = true;
            crossSectionModel.receiveShadow = true;
            scene.add(crossSectionModel);
        }
        
        // Setup model properties
        function setupModel(model) {
            model.traverse(function(child) {
                if (child.isMesh) {
                    // Enable shadows
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Clone material for manipulation
                    child.material = child.material.clone();
                    child.userData.originalMaterial = child.material.clone();
                    
                    // Create wireframe material
                    child.userData.wireframeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    // Create wireframe mesh
                    child.userData.wireframeMesh = new THREE.Mesh(child.geometry, child.userData.wireframeMaterial);
                    child.userData.wireframeMesh.visible = false;
                    child.add(child.userData.wireframeMesh);
                    
                    // Add outline effect for selection
                    child.userData.outlineMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        side: THREE.BackSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    child.userData.outlineMesh = new THREE.Mesh(child.geometry, child.userData.outlineMaterial);
                    child.userData.outlineMesh.scale.multiplyScalar(1.05);
                    child.userData.outlineMesh.visible = false;
                    child.add(child.userData.outlineMesh);
                }
            });
        }
        
        // Switch between models
        function switchModel() {
            if (!mainModel || !crossSectionModel) return;
            
            // Hide dimensions when switching
            hideDimensions();
            
            if (currentModel === mainModel) {
                mainModel.visible = false;
                crossSectionModel.visible = true;
                currentModel = crossSectionModel;
                document.getElementById('switchModel').innerHTML = '<i class="fas fa-cube"></i> Switch to Main';
                document.getElementById('thicknessItem').style.display = 'flex';
            } else {
                crossSectionModel.visible = false;
                mainModel.visible = true;
                currentModel = mainModel;
                document.getElementById('switchModel').innerHTML = '<i class="fas fa-layer-group"></i> Switch to Cross-Section';
                document.getElementById('thicknessItem').style.display = 'none';
            }
            
            // Apply wireframe if active
            toggleWireframeOnModel(currentModel, wireframeVisible);
            
            // Center the new model
            centerModel(currentModel);
            
            // Calculate and display dimensions
            calculateAndDisplayDimensions();
        }
        
        // Center model in view
        function centerModel(model) {
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Adjust controls target
            controls.target.copy(center);
            controls.update();
            
            // Adjust camera distance based on model size
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const distance = Math.abs(maxDim / Math.sin(fov / 2));
            
            camera.position.copy(center);
            camera.position.z += distance * 1.5;
            
            // Update camera
            camera.lookAt(center);
        }
        
        // Calculate and display dimensions
        function calculateAndDisplayDimensions() {
            if (!currentModel) return;
            
            // Calculate bounding box
            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3());
            
            // Convert to millimeters (assuming 1 unit = 1 meter)
            const scale = 1000; // Convert meters to millimeters
            const width = size.x * scale;
            const height = size.y * scale;
            const depth = size.z * scale;
            
            // Update dimension display
            document.querySelectorAll('.dimension-value')[0].textContent = width.toFixed(2);
            document.querySelectorAll('.dimension-value')[1].textContent = height.toFixed(2);
            document.querySelectorAll('.dimension-value')[2].textContent = depth.toFixed(2);
            
            // Calculate volume (approximate)
            const volume = (size.x * size.y * size.z) * 1000000; // Convert to cm³
            document.getElementById('volumeValue').textContent = volume.toFixed(2);
            
            // Calculate thickness for cross-section (minimum dimension)
            if (currentModel.name === 'cross-section') {
                const thickness = Math.min(width, height, depth);
                document.getElementById('thicknessValue').textContent = thickness.toFixed(2);
            }
        }
        
        // Show dimensions with timer
        function showDimensions() {
            if (!currentModel || dimensionsVisible) return;
            
            // Calculate dimensions
            calculateAndDisplayDimensions();
            
            // Show dimension panel and timer
            document.getElementById('dimensions').style.display = 'block';
            document.getElementById('timerDisplay').style.display = 'block';
            dimensionsVisible = true;
            
            // Apply wireframe overlay
            toggleWireframeOnModel(currentModel, true);
            
            // Start 5-minute countdown (300 seconds)
            let timeLeft = 300; // 5 minutes in seconds
            
            // Update countdown display
            function updateCountdown() {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('countdown').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft <= 0) {
                    hideDimensions();
                } else {
                    timeLeft--;
                }
            }
            
            // Only start countdown on first click
            if (clickCount === 0) {
                firstClickTime = Date.now();
                updateCountdown(); // Initial display
                countdownTimer = setInterval(updateCountdown, 1000);
                
                // Set auto-hide timer
                dimensionTimer = setTimeout(() => {
                    hideDimensions();
                }, 300000); // 5 minutes
            }
            
            clickCount++;
        }
        
        // Hide dimensions
        function hideDimensions() {
            if (!dimensionsVisible) return;
            
            document.getElementById('dimensions').style.display = 'none';
            document.getElementById('timerDisplay').style.display = 'none';
            dimensionsVisible = false;
            
            // Remove wireframe overlay
            toggleWireframeOnModel(currentModel, false);
            
            // Clear timers
            if (dimensionTimer) {
                clearTimeout(dimensionTimer);
                dimensionTimer = null;
            }
            
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            
            clickCount = 0;
            firstClickTime = null;
        }
        
        // Toggle wireframe on model
        function toggleWireframeOnModel(model, show) {
            if (!model) return;
            
            model.traverse(function(child) {
                if (child.isMesh && child.userData.wireframeMesh) {
                    child.userData.wireframeMesh.visible = show;
                    
                    // Add visual effect when wireframe is active
                    if (show) {
                        child.material.emissive = new THREE.Color(0x222222);
                        child.material.needsUpdate = true;
                    } else {
                        child.material.emissive = new THREE.Color(0x000000);
                        child.material.needsUpdate = true;
                    }
                }
            });
        }
        
        // Toggle grid visibility
        function toggleGrid() {
            gridVisible = !gridVisible;
            scene.traverse(function(child) {
                if (child.name === 'gridHelper') {
                    child.visible = gridVisible;
                }
            });
            
            // Update button text
            const button = document.getElementById('toggleGrid');
            button.innerHTML = gridVisible ? 
                '<i class="fas fa-th-large"></i> Hide Grid' : 
                '<i class="fas fa-th-large"></i> Show Grid';
        }
        
        // Toggle wireframe
        function toggleWireframe() {
            wireframeVisible = !wireframeVisible;
            toggleWireframeOnModel(currentModel, wireframeVisible);
            
            // Update button text
            const button = document.getElementById('toggleWireframe');
            button.innerHTML = wireframeVisible ? 
                '<i class="fas fa-th"></i> Hide Wireframe' : 
                '<i class="fas fa-th"></i> Show Wireframe';
        }
        
        // Toggle auto rotation
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            controls.autoRotateSpeed = 1.0;
            
            // Update button text
            const button = document.getElementById('autoRotate');
            button.innerHTML = autoRotate ? 
                '<i class="fas fa-stop"></i> Stop Rotation' : 
                '<i class="fas fa-sync"></i> Auto Rotate';
        }
        
        // Handle model click
        function onModelClick(event) {
            event.preventDefault();
            
            // Only handle left and right clicks
            if (event.button !== 0 && event.button !== 2) return;
            
            // Calculate mouse position
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Raycasting
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with visible models
            const visibleModels = [];
            scene.traverse(function(child) {
                if (child.isMesh && child.parent && 
                    (child.parent.name === 'main' || child.parent.name === 'cross-section') &&
                    child.parent.visible) {
                    visibleModels.push(child);
                }
            });
            
            const intersects = raycaster.intersectObjects(visibleModels, true);
            
            if (intersects.length > 0) {
                if (event.button === 0) { // Left click
                    // Highlight the clicked mesh
                    highlightMesh(intersects[0].object);
                    
                    // Show dimensions (timer doesn't restart on multiple clicks)
                    showDimensions();
                } else if (event.button === 2) { // Right click
                    // Hide dimensions immediately
                    hideDimensions();
                }
            } else {
                // Clicked outside model
                if (event.button === 2) { // Right click
                    hideDimensions();
                }
            }
        }
        
        // Highlight mesh on click
        function highlightMesh(mesh) {
            // Remove previous highlights
            scene.traverse(function(child) {
                if (child.isMesh && child.userData.outlineMesh) {
                    child.userData.outlineMesh.visible = false;
                }
            });
            
            // Highlight clicked mesh
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.visible = true;
                
                // Remove highlight after 2 seconds
                setTimeout(() => {
                    if (mesh.userData.outlineMesh) {
                        mesh.userData.outlineMesh.visible = false;
                    }
                }, 2000);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('mousedown', onModelClick);
            renderer.domElement.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            
            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    // Simulate left click for single touch
                    const touch = e.touches[0];
                    const clickEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    onModelClick(clickEvent);
                }
            });
            
            // Touch hold for right click (long press)
            let touchTimer;
            renderer.domElement.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    touchTimer = setTimeout(() => {
                        hideDimensions();
                    }, 500); // Long press duration
                }
            });
            
            renderer.domElement.addEventListener('touchend', function() {
                clearTimeout(touchTimer);
            });
            
            // Control buttons
            document.getElementById('switchModel').addEventListener('click', switchModel);
            document.getElementById('resetView').addEventListener('click', function() {
                controls.reset();
                centerModel(currentModel);
            });
            document.getElementById('autoRotate').addEventListener('click', toggleAutoRotate);
            document.getElementById('toggleWireframe').addEventListener('click', toggleWireframe);
            document.getElementById('toggleGrid').addEventListener('click', toggleGrid);
            document.getElementById('measureDistance').addEventListener('click', toggleMeasurementMode);
            document.getElementById('arButton').addEventListener('click', enterARMode);
            
            // Mobile control buttons
            document.getElementById('mobileRotate').addEventListener('click', toggleAutoRotate);
            document.getElementById('mobileZoomIn').addEventListener('click', function() {
                camera.position.multiplyScalar(0.9);
            });
            document.getElementById('mobileZoomOut').addEventListener('click', function() {
                camera.position.multiplyScalar(1.1);
            });
            document.getElementById('mobileReset').addEventListener('click', function() {
                controls.reset();
                centerModel(currentModel);
            });
            
            // Window resize
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                switch(e.key) {
                    case ' ':
                        switchModel();
                        break;
                    case 'r':
                    case 'R':
                        controls.reset();
                        centerModel(currentModel);
                        break;
                    case 'w':
                    case 'W':
                        toggleWireframe();
                        break;
                    case 'g':
                    case 'G':
                        toggleGrid();
                        break;
                    case 'Escape':
                        hideDimensions();
                        if (measurementMode) {
                            toggleMeasurementMode();
                        }
                        break;
                }
            });
        }
        
        // Setup mobile gestures
        function setupMobileGestures() {
            let initialDistance = 0;
            let initialScale = 1;
            
            renderer.domElement.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    // Pinch to zoom
                    const distance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    if (initialDistance === 0) {
                        initialDistance = distance;
                        initialScale = camera.position.length();
                    }
                    
                    const scale = initialScale * (distance / initialDistance);
                    camera.position.normalize().multiplyScalar(scale);
                }
            });
            
            renderer.domElement.addEventListener('touchend', function() {
                initialDistance = 0;
            });
        }
        
        // Toggle measurement mode
        function toggleMeasurementMode() {
            measurementMode = !measurementMode;
            
            if (measurementMode) {
                // Clear previous measurements
                measurePoints = [];
                if (measureLine) {
                    scene.remove(measureLine);
                    measureLine = null;
                }
                
                // Change cursor
                renderer.domElement.style.cursor = 'crosshair';
                
                // Add click listener for measurements
                renderer.domElement.addEventListener('click', onMeasurementClick);
                
                // Update button
                document.getElementById('measureDistance').innerHTML = 
                    '<i class="fas fa-times"></i> Cancel Measurement';
                    
                // Show instructions
                document.getElementById('instructions').innerHTML = `
                    <div class="instructions-title">
                        <i class="fas fa-ruler"></i>
                        MEASUREMENT MODE
                    </div>
                    <div class="instructions-content">
                        Click on two points to measure distance<br>
                        Press ESC to cancel
                    </div>
                `;
            } else {
                // Restore normal cursor
                renderer.domElement.style.cursor = 'grab';
                
                // Remove measurement listener
                renderer.domElement.removeEventListener('click', onMeasurementClick);
                
                // Remove measurement line
                if (measureLine) {
                    scene.remove(measureLine);
                    measureLine = null;
                }
                
                // Update button
                document.getElementById('measureDistance').innerHTML = 
                    '<i class="fas fa-ruler"></i> Measure Distance';
                    
                // Restore instructions
                document.getElementById('instructions').innerHTML = `
                    <div class="instructions-title">
                        <i class="fas fa-info-circle"></i>
                        HOW TO INTERACT
                    </div>
                    <div class="instructions-content">
                        <span style="color: #667eea;">• Tap/Drag:</span> Rotate 
                        <span style="color: #667eea; margin-left: 15px;">• Scroll/Pinch:</span> Zoom 
                        <span style="color: #667eea; margin-left: 15px;">• Right-click/Hold:</span> Pan
                    </div>
                `;
            }
        }
        
        // Handle measurement clicks
        function onMeasurementClick(event) {
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(currentModel, true);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                
                // Create a sphere at the measurement point
                const sphereGeometry = new THREE.SphereGeometry(0.02);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(point);
                scene.add(sphere);
                
                // Store reference to remove later
                measurePoints[measurePoints.length - 1].marker = sphere;
                
                if (measurePoints.length === 2) {
                    // Calculate distance
                    const distance = measurePoints[0].distanceTo(measurePoints[1]);
                    const distanceMM = distance * 1000; // Convert to mm
                    
                    // Create line between points
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(measurePoints);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, 
                        linewidth: 2 
                    });
                    
                    if (measureLine) {
                        scene.remove(measureLine);
                    }
                    
                    measureLine = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(measureLine);
                    
                    // Create label
                    const midPoint = new THREE.Vector3()
                        .addVectors(measurePoints[0], measurePoints[1])
                        .multiplyScalar(0.5);
                    
                    // Show measurement result
                    alert(`Distance: ${distanceMM.toFixed(2)} mm`);
                    
                    // Reset for next measurement
                    setTimeout(() => {
                        measurePoints.forEach(p => {
                            if (p.marker) scene.remove(p.marker);
                        });
                        if (measureLine) scene.remove(measureLine);
                        measurePoints = [];
                        measureLine = null;
                    }, 3000);
                }
            }
        }
        
        // Enter AR mode
        async function enterARMode() {
            if (!arSupported) {
                alert('AR is not supported on this device');
                return;
            }
            
            // Hide UI elements
            document.getElementById('controls').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('arButton').style.display = 'none';
            
            // Configure renderer for AR
            renderer.xr.enabled = true;
            
            // Create AR button
            const arButton = document.createElement('button');
            arButton.innerHTML = '<i class="fas fa-times"></i> Exit AR';
            arButton.className = 'btn';
            arButton.style.position = 'absolute';
            arButton.style.bottom = '20px';
            arButton.style.left = '50%';
            arButton.style.transform = 'translateX(-50%)';
            arButton.style.zIndex = '1000';
            arButton.onclick = exitARMode;
            document.getElementById('container').appendChild(arButton);
            
            // Start AR session
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            });
            
            renderer.xr.setSession(session);
            isARMode = true;
            
            // Scale model for AR
            currentModel.scale.set(0.5, 0.5, 0.5);
            
            // Position model in front of camera
            currentModel.position.set(0, 0, -2);
        }
        
        // Exit AR mode
        function exitARMode() {
            if (!isARMode) return;
            
            // Exit XR session
            if (renderer.xr.getSession()) {
                renderer.xr.getSession().end();
            }
            
            renderer.xr.enabled = false;
            isARMode = false;
            
            // Show UI elements
            document.getElementById('controls').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('arButton').style.display = 'block';
            
            // Remove exit button
            const exitButton = document.querySelector('#container button:last-child');
            if (exitButton) {
                exitButton.remove();
            }
            
            // Reset model scale and position
            currentModel.scale.set(1, 1, 1);
            centerModel(currentModel);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Auto rotate if enabled
            if (autoRotate) {
                currentModel.rotation.y += 0.005;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
